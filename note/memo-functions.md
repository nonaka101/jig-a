# 設計メモ

## 各種機能

### 全体に関係するもの

#### `input[type="date"]` のブラウザ互換性について

`input[type="date"]` はブラウザが対応している状態においては利便性が高い一方、非対応の場合が問題となる。

`input` の入力値は `yyyy-MM-dd` の形式となっており、コードもそれ前提に処理を行う。だが非対応の場合、`input[type="text"]` と同様になるため、多様な入力ができてしまう。そして `20000123` ではダメで、ハイフンを交えた `2000-01-23` という入力をユーザーにしてもらわなければならない。

パターン指定（例：`pattern="\d{4}-\d{2}-\d{2}"`）で入力値を制限するという手法が、まず考えられる。この場合、パターンに一致しなければ「適切な形で入力してください」的なポップアップが表示されるので、間違いであることは伝わるが**どこがどのように誤りなのか**はユーザーには伝わらない。この場合には、最低限でもラベル等に**適切な入力例**がわかるようする必要がある。

> [!CAUTION]
> `{inputElement}.pattern = "\d{4}-\d{2}-\d{2}"` だとエスケープが自動処理されてしまうので、`String.raw` で生の文字列を使う必要がある。

一方で、`input[type="date"]` が有効な状況下で「入力値は `yyyy-MM-dd` の形式でなければなりません」というラベルがあると、ユーザーは混乱してしまう恐れがある。そこで、**非対応かを調べ、非対応の場合のみラベルで注記を促す**ようすることがベターな選択肢として浮上する。機能を検証する手段として、Javascript上で要素を生成して確認する手法がポピュラーである。

```javascript
const inputDateTest = document.createElement('input');
try {
  inputDateTest.type = 'date';
} catch (e) {
  console.log(e.message);
}
if (inputDateTest.type === 'text') {
  // date 非対応のためのコード
}
```

### B:計算

#### b01-calculator

簡易電卓、基本的な四則演算ができる。

設計の際の課題は、下記の2点。

- 少数の計算の際、丸め誤差が生じる
- 計算式の入力位置によって、入力できる内容が変化する
- ダイアログ展開中は、キー入力を可能にしたい

##### 少数計算の丸め誤差について

少数を含む計算はそのままでは不都合だったので、整数での計算に置き換える必要がある。
なので、一度少数は整数へと変換する措置を施し、計算後にその措置を逆算する形で、少数での計算結果に戻す。

##### 計算式の位置に応じた入力内容について

状態遷移の考えをベースとして、入力の整合性をチェックする。

まずは下記のような計算式の位置に応じたステートを用意、状態を管理できるようにする。

|State名|数値|説明|
|:---|:---:|:---|
|Start|0|初期状態|
|NegativeNum1|1|左辺：マイナス符号を入力|
|OperandZero1|2|左辺：ゼロ入力状態|
|OperandInteger1|3|左辺：整数モード|
|OperandDecimal1|4|左辺：少数モード|
|Operator|5|演算子入力|
|NegativeNum2|6|右辺：マイナス符号を入力|
|OperandZero2|7|右辺：ゼロ入力状態|
|OperandInteger2|8|右辺：整数モード|
|OperandDecimal2|9|右辺：少数モード|
|Result|10|計算結果|

上記ステートで入力できる内容と、入力後に遷移するステートを表すと、下表のようになる。

| 状態名 / 取りうる値 | 0 | 1-9 | . | - | +, *, / | = |
|----------------------|---|-----|---|---|---------------|---|
| Start                | OperandZero1 | OperandInteger1 | OperandDecimal1 | NegativeNum1 | - | - |
| NegativeNum1         | OperandZero1 | OperandInteger1 | OperandDecimal1 | - | - | - |
| OperandZero1         | - | OperandInteger1 | OperandDecimal1 | Operator | Operator | - |
| OperandInteger1      | OperandInteger1 | OperandInteger1 | OperandDecimal1 | Operator | Operator | - |
| OperandDecimal1      | OperandDecimal1 | OperandDecimal1 | - | Operator | Operator | - |
| Operator             | OperandZero2 | OperandInteger2 | OperandDecimal2 | NegativeNum2 | - | - |
| NegativeNum2         | OperandZero2 | OperandInteger2 | OperandDecimal2 | - | - | - |
| OperandZero2         | - | OperandInteger2 | OperandDecimal2 | Operator(*) | Operator(*) | Result |
| OperandInteger2      | OperandInteger2 | OperandInteger2 | OperandDecimal2 | Operator(*) | Operator(*) | Result |
| OperandDecimal2      | OperandDecimal2 | OperandDecimal2 | - | Operator(*) | Operator(*) | Result |
| Result               | OperandZero1 | OperandInteger1 | OperandDecimal1 | Operator | Operator | - |

(*): 一度 Result を経由して Operator に移行する

##### ダイアログ展開中のテンキー使用について

現行のバージョンでは、ダイアログの状態を `MutationObserver` を使って監視、展開時のみテンキー等を使えるようにしている。

OS上の電卓アプリでは、エンターキーを `=` と同等の扱いにしていることが多いが、Web上においてはイベント発火に使っている関係から、操作不能になることを避けるためにテンキー側のみに限定している。

### C:テキスト

#### c01-text-counter

入力されたテキストの文字列をカウントする機能。

設計の際の課題は、下記となる

- 絵文字やサロゲートペアも1文字として検出する必要がある
- 空行判定がおかしい場合がある

##### 1文字としてカウントすることについて

マルチバイト文字を利用する環境下では、単純な `String().length` では文字数をカウントできない場合がある。下表は、絵文字やサロゲートペア文字に対し、いくつかの方法で長さを求めた結果である。

|文字|`String().length`|`String().match(/\S/gui).length` / `Array.from().length`|
|:---:|:---:|:---:|
|𩸽|2|1|
|🍎|2|1|
|🏴󠁧󠁢󠁥󠁮󠁧󠁿|14|7|
|🇯🇵|4|2|
|👨🏻‍💻|7|4|

これに対し、`Intl.Segmenter` を使うと、全て1文字としてカウントしてくれるようになった。

##### 空行判定について

現行のコードでは解消されているが、以前のものは正規表現が少し変になっていた。

現行においては OS 上の表記ブレを想定し、改行を LF( = `\n`) に統一するよう整形した上で処理を進めるようにしている。

#### c02-excel2md

Excel や Google Sheet などの表形式データ（`\t`, `\n` により区切られているデータ）を、`markdown` のテーブル形式に変換する機能。

設計の際の課題は、下記となる

- パイプ記号 `|` を使っている場合のエスケープ処理

##### エスケープ処理について

`markdown` テーブルは、パイプ記号 `|` をデータ区切りに使っているため、セルに `|` が含まれている場合はエスケープ処理が必要となる。

今回は（エスケープ処理を考えない）**ベースとなる処理** と、それをラップする形で**エスケープ処理付きの処理**で設計した。ベースとなる処理に渡す際には、`|` を `@@PIPE@@` など通常使われえない文字列へと対比する形で置き換え、処理の完了後に `\|` といったエスケープシーケンスを使って再置換する。

当初は `\\|` という形にしていたが、これは**スクリプト上で文字列リテラルを作る際、自動的にエスケープ処理されてしまう**ことが原因だった。しかし `textarea` 要素等で入力を受け付け、`{Element}.value` で引き出し処理する際は**エスケープ処理されない生の文字列**となるため、`\|` で処理しても問題ないことが確認できた。

> [!TIP]
> 生の文字列を扱うよう `String.raw` を使う等でも対応することができる模様。

#### c03-md2excel

**c02** とは逆に `markdown` テーブルを、表形式データに変換する機能。課題等については、[c02-excel2md](#c02-excel2md)と同一なのでそちらを参照。

### D:暦・日付・期間

#### d00

汎用なものとして、下記を準備

- 和暦に関する諸情報を管理するためのオブジェクト `wareki`
- 生年月日から、年齢を計算する `calcAge()`
- ２つの日付間にある日数（絶対値）を算出 `dateDiff()`
- 日付文字列が適正な日付かを判定 `isDateFormat()`

#### d01-calculate-age

生年月日から、年齢（＋経過日数）を算出する機能。

設計の際の課題は、下記の通り。

- 加齢タイミングについて（閏日前後が生年月日の場合にも対応）
- バリデーションエラーの時の対応
- `input[type="date"]` が未対応のための対策（これは[全体に関係するもの](#全体に関係するもの)に記載）

※一部の書類では満年齢の他に「◯歳◯ヶ月」と記入するものもあり、月数を算出する需要がある。しかし日数と違い月数は *時期により 28-31 と日数が散らばっている* 関係から実装する難度が跳ね上がってしまう問題があった。そのため、算出しやすい日数のみ導入することに。

##### 加齢タイミングは、誕生日前日24時

本件において、加齢するタイミングをどこに引くかが大きな要点となる。例えば「**閏年の2/29日**に生まれた人が、4年に1度しか歳を取らない」といった事態は避けなければならない。

また（概算値ならともかく）「誕生日から365日ずつ回して算出する」という手法も適切でない。閏年により1年の日数は変わるし、今回は経過日数も必要となるので（ある程度の）精度を持つ値が必要である。

そこで『[年齢計算ニ関スル法律 | e-Gov 法令検索](https://laws.e-gov.go.jp/law/135AC1000000050)』より、**誕生日前日の24時**のタイミングで加齢する考えを持ってきている。この場合、閏日前後が誕生日となる場合は下表のようになる。

|誕生日|加齢時（閏年でない場合）|加齢時（閏年の場合）|
|:---:|:---|:---|
|2/29|2/28 24:00(≒ 3/1 0:00)|2/28 24:00(≒ 2/29 0:00)|
|3/1|2/28 24:00(≒ 3/1 0:00)|2/29 24:00(≒ 3/1 0:00)|

##### ２箇所にある要素のバリデーションエラーについて

本機能には、「生年月日（西暦形式で `input[type="date"]`）」と「生年月日（和暦形式で`input[type="text"]`）」の２箇所入力ボックスがある。そして西暦形式の入力値が適正な場合にのみ、「計算」ボタンを押せるようにしておく必要がある。

和暦形式の方は、入力が適正でない場合はラベル欄に赤字で「６桁の年月日文字列にしてください」という文面を生成するように。

西暦方式の方は、「計算ボタン」の `disabled` 属性を操作できるようにし、適正な値のみ解除するようにしている。

#### d02-clock

現在の日付や時刻を画面全体に表示する機能。ボタン形式になっており、押すと内容を読み上げてくれる機能も備えている（音を出す設定時のみ）

設計の際の課題は、下記の通り。

- ダイアログ展開時に限定した非同期処理
- アクセシビリティな時計（例：読み上げ機能とスクリーンリーダーとの干渉）

##### 非同期処理として行う時刻更新

非同期処理はダイアログ展開時のみ行うようしたいので、`MutationObserver` を使って監視するように。

```javascript
const dialogEle = document.querySelector("#dialog");
let intervalId;

// MutationObserverでdialog要素の属性の変化を監視
const observer = new MutationObserver((mutationsList) => {
  for (const mutation of mutationsList){
    if (mutation.type === 'attributes' && mutation.attributeName === 'open') {
      if (dialogEle.open) {
        intervalId = setInterval(updateTime, 1000);
      } else {
        clearInterval(intervalId);
      }
    }
  }
});

// open属性の変化を監視
observer.observe(dialogEle, {
  attributes: true,
  attributeFilter: ["open"],
});
```

##### アクセシビリティ性のある時計について

本リポジトリの特徴として、アクセシビリティ性を挙げている。その上で、**時計にどのような UI が求められているか**を考える必要がある。

- 一般
  - どのようなサイズでも、見栄え良く、きちんと認識できるようにしたい
  - ボタンを押して時刻読み上げ、というのは必要？
  - 「音」設定項目がある以上、それに連動させるべき？
- キーボード操作
  - 特段の何か、が必要ではない？
- スクリーンリーダー
  - `aria-polite` で逐次時刻を読み上げるのは論外
  - ボタン内のテキストは都度更新されるので、`aria-hidden` で隠す？
  - その上で、ボタンの `aria-label` を「時刻読み上げ」とし、押下時に読み上げ？
  - 「音」設定は、スクリーンリーダー的には不要な項目であるため、その設定が無いと読み上げしないのは不便
  - 代替として、`sr-only` 特性を持つ `output` 要素を生成し、読み上げに使う？
    - ただし、再度押下時に既存のものをどう扱うかが問題となる
    - 上記をテストした際、一瞬だけ出力し消した場合でも読み上げてくれた

こうしたことから、音の設定をしている場合にボタンを押下すると、WebSpeechAPI を使って読み上げるようにした。

そして音の設定を切っている場合は、スクリーンリーダー用に、`hp_srOnly` 要素の `output` に一瞬だけ時刻テキスト付きの `span` を付与（付与した後にすぐ削除）している。  
これにより 必要な情報を読み上げた上、それが残って現在時間と勘違いされることはないはず。

### E:単位（変換・換算）
